#!/usr/bin/python3

# SPDX-License-Identifier: MPL-2.0

import time
import signal
import re
import os
import sys
import getopt
import shutil
import shlex
import traceback

import serial # maybe at some point, pull this in, as PySerial is pure python.  Currently need "pip install PySerial"...
import oc_pylib.util as util # our own library of helpers

util.progname_in_message = False # too noise for this use case

# **************************************************************
# **** Readline related

try:
    import readline
    got_readline = 1
except:
    got_readline = 0
    pass


if got_readline:
    histfile = os.path.join(os.path.expanduser("~"), ".oc_cli_history")
    try:
        readline.read_history_file(histfile)
        readline.set_history_length(1000)
    except FileNotFoundError:
        pass


# **************************************************************
# **** Global vars

global_vars = {}

def apply_global_vars(text):
    global global_vars
    for key in global_vars.keys():
        text = text.replace("$%s" % key, global_vars[key])
    return text

def eval_true(text):
    tt = apply_global_vars(text).lower()
    if tt=="t" or tt=="true" or tt=="1" or tt=="yes" or tt=="on": return True
    if tt=="f" or tt=="false" or tt=="0" or tt=="no" or tt=="off": return False
    util.warning(f"Expected a boolean, got '{text}', assuming that means 'False'")
    return False

def eval_number(text, ishex=False, check_uint_bits=False, check_int_min=False, check_int_max=False):
    # if we've been given an int already, set the value to that
    if isinstance(text, int):
        value = text
    else:
        mult = 1
        # do variable substitution
        text = apply_global_vars(text)
        # look for a prefix for human friendly number, note these suffixes work on hex numbers too
        m = re.match(r'^(.*)[Kk]$', text)
        if m:
            mult = 1024
            text = m.group(1)
        m = re.match(r'^(.*)[Mm]$', text)
        if m:
            mult = 1024*1024
            text = m.group(1)
        m = re.match(r'^(.*)[Gg]$', text)
        if m:
            mult = 1024*1024*1024
            text = m.group(1)
        # substition is done, multiplier is extracted, time to look for a number
        value = False
        if not ishex: # if we've been told it's hex, we don't do this match, because hex can look decimal
            m = re.match(r'^(\d+)$', text)
            if m: value = int(m.group(1)) * mult
        if (type(value) != int):
            m = re.match(r'^0x([\da-fA-F]+)$', text) # if it's starts with 0x, then it's hex
            if m: value = int(m.group(1), 16) * mult
        if (type(value) != int):
            m = re.match(r'^([\da-fA-F]+)$', text) # if it has a-f, then it's hex
            if m: value = int(m.group(1), 16) * mult
        # if we don't have value as an int by here, we are out of ideas
        if (type(value) != int):
            util.error(f"Expected a number, got '{text}'", do_exit=False)
            raise HandledError
    # if we're given a number of uint bits to check, convert to int min/max
    if (type(check_uint_bits) == int):
        check_int_min = 0
        check_int_max = (1 << check_uint_bits)-1
    # check value is within int min/max
    if (type(check_int_min) == int):
        if (value < check_int_min):
            util.error(f"Expected a number >= {check_int_min}, got {value}", do_exit=False)
            raise HandledError
    if (type(check_int_max) == int):
        if (value > check_int_max):
            util.error(f"Expected a number <= {check_int_max}, got {value}", do_exit=False)
            raise HandledError
    return value

def eval_regex(regex, text):
    global m
    text = apply_global_vars(text)
    m = re.match(regex, text)
    return m

# **************************************************************
# **** Serial-Over-Tcp

class FakeSerial:
    def __init__(self, port, timeout) -> None:
        try:
            tcpTuple = port.split(":", 1)[1].split(",")
            self.ip = tcpTuple[0]
            self.baseport = int(tcpTuple[1])
            self.devno = int(tcpTuple[2])
            self.inBuf = bytearray()
            self.timeout = timeout
        except:
            raise AttributeError("Fake serial port must be specified as: tcp:IPAddress,UARTBasePort,UARTDeviceNumber")
        self.sck = socket.create_connection(("127.0.0.1", self.baseport+self.devno))
        self.sck.settimeout(0)
    def read(self, nBytes):

        starttime = time.monotonic()

        while (len(self.inBuf) < nBytes) and ((time.monotonic() - starttime) < self.timeout):
            try:
                data = self.sck.recv(4096)
            except BlockingIOError:
                data = b''
            self.inBuf.extend(data)

        requested = self.inBuf[:nBytes]
        nextdata = self.inBuf[nBytes:]
        self.inBuf = nextdata
        return bytes(requested)
    def write(self, data):
        ret = self.sck.send(data)
        return ret
    def close(self):
        self.sck.close()
    @property
    def in_waiting(self):
        return len(self.inBuf)
    @property
    def out_waiting(self):
        return 0


# **************************************************************
# **** XXTEA for Protection

# ported from https://en.wikipedia.org/wiki/XXTEA

def btea (vin, n, key):
    v = vin
    DELTA = 0x9e3779b9
    if (n > 1): # Encoding part
        rounds = int(6 + 52/n)
        s = 0
        z = v[n-1]
        while rounds:
            s = (s + DELTA) & 0xffffffff
            e = (s >> 2) & 3;
            for p in range(n-1):
                y = v[p+1]
                v[p] = (v[p] + (((z>>5^y<<2) + (y>>3^z<<4)) ^ ((s^y) + (key[(p&3)^e] ^ z)))) & 0xffffffff
                z = v[p]
            p = n-1
            y = v[0]
            v[n-1] = (v[n-1] + (((z>>5^y<<2) + (y>>3^z<<4)) ^ ((s^y) + (key[(p&3)^e] ^ z)))) & 0xffffffff
            z = v[n-1]
            rounds -= 1
    elif (n < -1): # Decoding part
        n = -n
        rounds = int(6 + 52/n)
        s = (rounds * DELTA) & 0xffffffff
        y = v[0]
        while rounds:
            e = (s >> 2) & 3
            for p in range(n-1, 0, -1):
                z = v[p-1]
                v[p] = (v[p] - (((z>>5^y<<2) + (y>>3^z<<4)) ^ ((s^y) + (key[(p&3)^e] ^ z)))) & 0xffffffff
                y = v[p]
            p = 0
            z = v[n-1]
            v[0] = (v[0] - (((z>>5^y<<2) + (y>>3^z<<4)) ^ ((s^y) + (key[(p&3)^e] ^ z)))) & 0xffffffff
            y = v[0]
            s = (s - DELTA) & 0xffffffff
            rounds -= 1
    return v

# **************************************************************
# **** Blocks
block_table = {}


class Block():
    def __init__(self, channel, blockid, name="Unknown"):
        self.channel = channel
        self.blockid = blockid
        self.name = name

    def __str__(self):
        return f"Block {self.name} [{self.blockid}]"

    def info    (self, text): util.info    (f"{self.name}[{self.blockid}]: {text}")
    def debug   (self, text): util.debug   (f"{self.name}[{self.blockid}]: {text}")
    def warning (self, text): util.warning (f"{self.name}[{self.blockid}]: {text}")
    def error   (self, text): util.error   (f"{self.name}[{self.blockid}]: {text}")

    def connect(self):
        util.debug(f"Connecting {self.name}@{self.blockid}")

    def disconnect(self):
        util.debug(f"Disconnecting {self.name}@{self.blockid}")

    def csr_read32(self, space, address, msgid=0, verbose=False):
        util.debug(f"{self}: csr_read32(space={space},address={address:08x})")
        return self.channel.csr_read32(self.blockid, space, address, msgid, verbose)

    def csr_write32(self, space, address, data, msgid=0, verbose=False):
        util.debug(f"{self}: csr_write32(space={space},address={address:08x}, data={data:08x})")
        return self.channel.csr_write32(self.blockid, space, address, data, msgid, verbose)

    def command_show(self, parts=[], help_line=False):
        if help_line: return "Shows high level status of the block in human readable form";
        self.warning(f"Command 'show' was called on a block type for which there is no handler")

    def command_dump(self, parts=[], help_line=False):
        if help_line: return "Dumps detailed config/status info of the block in human readable form";
        self.warning(f"Command 'dump' was called on a block type for which there is no handler")

    def command_help(self, parts=[], help_line=False):
        if help_line: return "This help";
        util.info(f"Help for {self}")
        for func in sorted([a for a in dir(self) if callable(getattr(self, a))]):
            m = re.match(r'command_(\w+)', func)
            if m:
                cmd = m.group(1)
                util.info(f"{cmd:20} : {getattr(self,func)(help_line=True)}")

    def dump_reg (self, space, address, name, fields=[], end='\n'):
        data = self.csr_read32(space, address)
        util.info("REG [%02x][%01x][%08x] (%-28s) = %08x" % (self.blockid, space, address, name, data), end=end)
        for field in fields:
            msb = field[0]
            lsb = field[1]
            fieldname = field[2]
            width = (msb-lsb+1)
            mask = (1<<width)-1
            if msb == lsb:
                util.info("                 [%2d] %-28s   = %8x" % (lsb, fieldname, ((data >> lsb) & 1)))
            else:
                digits = int((width+3)/4)
                fmt = "              [%%2d:%%2d] %%-28s   = %s%%0%dx" % (' '*(8-digits), digits)
                util.info(fmt % (msb, lsb, fieldname, ((data >> lsb) & mask)), end=end)
        return data

    def process_tokens(self, parts):
        command = parts.pop(0)
        if (f"command_{command}" in dir(self)) and callable(getattr(self,f"command_{command}")):
            util.debug(f"About to launch into method command_{command}")
            getattr(self,f"command_{command}")(parts)
        else:
            util.warning(f"Didn't understand command: '{command}'")


# **** BlockChipMon


class BlockChipMon(Block):
    def __init__(self, channel, blockid):
        Block.__init__(self, channel, blockid, "ChipMon")

    def connect(self):
        Block.connect(self)
        data = self.csr_read32(0, 0)
        self.csrid = ((data >> 16) & 0xff)
        self.internal_reference = ((data >> 16) & 0x1)
        util.debug(f"Connect: {self} CsrId={self.csrid} InternalReference={self.internal_reference}")

    def chipmon_code_to_temp(self, code):
        return (((code * 507.5921310)/65536)-279.42657680)

    def chipmon_code_to_volt(self, code, voltagerange="normal"):
        if voltagerange=="normal":
            return 3.0*(code/65536)
        else:
            return 6.0*(code/65536)

    def command_show(self, parts=[], help_line=False):
        if help_line: return "Shows high level status of the block in human readable form";
        t = self.chipmon_code_to_temp(self.csr_read32(1, 0x0))
        t_min = self.chipmon_code_to_temp(self.csr_read32(1, 0x24))
        t_max = self.chipmon_code_to_temp(self.csr_read32(1, 0x20))
        vint = self.chipmon_code_to_volt(self.csr_read32(1, 0x1))
        vint_min = self.chipmon_code_to_volt(self.csr_read32(1, 0x25))
        vint_max = self.chipmon_code_to_volt(self.csr_read32(1, 0x21))
        vaux = self.chipmon_code_to_volt(self.csr_read32(1, 0x2))
        vaux_min = self.chipmon_code_to_volt(self.csr_read32(1, 0x26))
        vaux_max = self.chipmon_code_to_volt(self.csr_read32(1, 0x22))
        vbram = self.chipmon_code_to_volt(self.csr_read32(1, 0x6))
        vbram_min = self.chipmon_code_to_volt(self.csr_read32(1, 0x27))
        vbram_max = self.chipmon_code_to_volt(self.csr_read32(1, 0x23))
        util.info(f"Temperature : {t:5.1f}C (seen {t_min:5.1f}C - {t_max:5.1f}C)")
        util.info(f"VCCint      : {vint:5.3f}V (seen {vint_min:5.3f}V - {vint_max:5.3f}V)")
        util.info(f"VCCaux      : {vaux:5.3f}V (seen {vaux_min:5.3f}V - {vaux_max:5.3f}V)")
        util.info(f"VCCbram     : {vbram:5.3f}V (seen {vbram_min:5.3f}V - {vbram_max:5.3f}V)")

    def command_dump(self, parts=[], help_line=False):
        if help_line: return "Dumps detailed config/status info of the block in human readable form";
        self.info(f"Dumping {self}:")
        self.dump_reg(0, 0x0000, "OcID", [ [31,16,"ID"],
                                           [0,0,"INTERNAL_REF"] ])
        self.dump_reg(0, 0x0001, "OcChipMon0", [ [29,29,"JTAG_BUSY"], [29,29,"JTAG_MODIFIED"],
                                                 [28,28,"JTAG_LOCKED"], [0,0,"RESET"] ])
        self.dump_reg(0, 0x0002, "OcChipMon1", [ [31,16,"ALARM"], [0,0,"OVER_TEMP"] ])
        self.dump_reg(1, 0x003e, "Flags1", [ [3,0,"ALARM[11:8]"] ])
        self.dump_reg(1, 0x003f, "Flags2", [ [11,11,"JTAG_DISABLE"], [10,10,"JTAG_RESTRICTED"],
                                             [9,9,"INTERNAL_REFERENCE"],
                                             [7,4,"ALARM[6:3]"], [3,3,"OVER_TEMP"], [2,0,"ALARM[2:0]"]])
        self.dump_reg(1, 0x0040, "ConfigReg0", [ [15,15,"DISABLE_CAL"], [13,12,"SAMPLE_AVERAGING"],
                                                 [11,11,"EXT_MUX_MODE"], [10,10,"BIPOLAR_INPUTS"],
                                                 [9,9,"EVENT_DRIVEN"], [8,8,"10_CYCLE_SLOW_ACQ"],
                                                 [5,0,"CHANNEL"] ])
        self.dump_reg(1, 0x0041, "ConfigReg1", [ [15,12,"SEQUENCER_MODE"], [11,8,"ALARM_DISABLE[6:3]"],
                                                 [7,4,"CAL[3:2:-:0]"], [3,1,"ALARM_DISABLE[2:0]"],
                                                 [0,0,"OVER_TEMP_DISABLE"]])
        self.dump_reg(1, 0x0042, "ConfigReg2", [ [15,8,"ADCCLK_DIV"] ])
        self.dump_reg(1, 0x0043, "ConfigReg3", [ [14,8,"I2C_ADDR"], [7,7,"I2C_ENABLE"],
                                                 [3,0,"ALARM_DISABLE[11:8]"]])
        self.dump_reg(1, 0x0044, "ConfigReg4", [ [11,10,"SLOW_EOS"], [9,8,"SLOW_SEQ"], [3,0,"PMBUS_HRIO"]])
        self.dump_reg(1, 0x0046, "SequenceReg0", [ [3,3,"CHSEL_USER3"], [2,2,"CHSEL_USER2"],
                                                   [1,1,"CHSEL_USER1"], [0,0,"CHSEL_USER0"] ])
        self.dump_reg(1, 0x0048, "SequenceReg1", [ [14,14,"CHSEL_BRAM_AVG"], [13,13,"CHSEL_VREFN"],
                                                   [12,12,"CHSEL_VREFP"], [11,11,"CHSEL_VPVN"],
                                                   [10,10,"CHSEL_AUX_AVG"], [9,9,"CHSEL_INT_AVG"],
                                                   [8,8,"CHSEL_TEMP"], [7,7,"CHSEL_VCC_PSAUX"],
                                                   [6,6,"CHSEL_VCC_PSINTFP"], [5,5,"CHSEL_VCC_PSINTLP"],
                                                   [0,0,"CHSEL_SYSMON_CAL"] ])
        self.dump_reg(1, 0x0049, "SequenceReg2", [ [15,0,"CHSEL_AUX[15:0]"]])
        self.dump_reg(1, 0x007a, "SlowChSel0", [ [14,14,"SLOW_BRAM"], [13,13,"SLOW_VREFN"], [12,12,"SLOW_VREFP"],
                                                 [11,11,"SLOW_VPVN"], [10,10,"SLOW_AUX_AVG"], [9,9,"SLOW_INT_AVG"],
                                                 [8,8,"SLOW_TEMP"], [7,7,"SLOW_VCC_PSAUX"], [6,6,"SLOW_VCC_PSINTFP"],
                                                 [5,5,"SLOW_VCC_PSINTLP"], [0,0,"SLOW_SYSMON"]])
        self.dump_reg(1, 0x007b, "SlowChSel1", [ [15,0,"SLOW_AUX[15:0]"]])
        self.dump_reg(1, 0x007c, "SlowChSel2", [ [3,0,"SLOW_USER[3:0]"]])
        self.dump_reg(1, 0x0047, "AvgChSel0", [ [3,0,"AVG_USER[3:0]"]])
        self.dump_reg(1, 0x004a, "AvgChSel1", [ [15,0,"AVG_AUX[15:0]"]])
        self.dump_reg(1, 0x004b, "AvgChSel2", [ [14,14,"AVG_BRAM"],
                                                [11,11,"AVG_VPVN"], [10,10,"AVG_AUX_AVG"], [9,9,"AVG_INT_AVG"],
                                                [8,8,"AVG_TEMP"], [7,7,"AVG_VCC_PSAUX"], [6,6,"AVG_VCC_PSINTFP"],
                                                [5,5,"AVG_VCC_PSINTLP"]])
        self.dump_reg(1, 0x004c, "SeqInMode0", [ [11,11,"INSEL_VPVN"]])
        self.dump_reg(1, 0x004d, "SeqInMode1", [ [15,0,"INSEL_AUX[15:0]"]])
        self.dump_reg(1, 0x004e, "SeqAcq0", [ [11,11,"ACQ_VPVN"]])
        self.dump_reg(1, 0x004f, "SeqAcq1", [ [15,0,"ACQ_AUX[15:0]"]])

        data = self.dump_reg(1, 0x0050, "Temperature Upper", [], end="")
        print(" (%.1fC)" % (self.chipmon_code_to_temp(data)))
        data = self.dump_reg(1, 0x0051, "VCCint Upper", [], end='')
        print(" (%.3fV)" % (self.chipmon_code_to_volt(data)))
        data = self.dump_reg(1, 0x0052, "VCCaux Upper", [], end='')
        print(" (%.3fV)" % (self.chipmon_code_to_volt(data)))
        data = self.dump_reg(1, 0x0053, "Over Temp Upper", [], end='')
        print(" (%.1fC)" % (self.chipmon_code_to_temp(data)))
        data = self.dump_reg(1, 0x0054, "Temperature Lower", [], end='')
        print(" (%.1fC)" % (self.chipmon_code_to_temp(data)))
        data = self.dump_reg(1, 0x0055, "VCCint Lower", [], end='')
        print(" (%.3fV)" % (self.chipmon_code_to_volt(data)))
        data = self.dump_reg(1, 0x0056, "VCCaux Lower", [], end='')
        print(" (%.3fV)" % (self.chipmon_code_to_volt(data)))
        data = self.dump_reg(1, 0x0057, "Over Temp Lower", [], end='')
        print(" (%.1fC)" % (self.chipmon_code_to_temp(data)))
        data = self.dump_reg(1, 0x0058, "VCCbram Upper", [], end='')
        print(" (%.3fV)" % (self.chipmon_code_to_volt(data)))
        data = self.dump_reg(1, 0x005c, "VCCbram Lower", [], end='')
        print(" (%.3fV)" % (self.chipmon_code_to_volt(data)))
        data = self.dump_reg(1, 0x0000, "Temperature", [], end='')
        print(" (%.1fC)" % (self.chipmon_code_to_temp(data)))
        data = self.dump_reg(1, 0x0001, "VCCint", [], end='')
        print(" (%.3fV)" % (self.chipmon_code_to_volt(data)))
        data = self.dump_reg(1, 0x0002, "VCCaux", [], end='')
        print(" (%.3fV)" % (self.chipmon_code_to_volt(data)))
        data = self.dump_reg(1, 0x0006, "VCCbram", [], end='')
        print(" (%.3fV)" % (self.chipmon_code_to_volt(data)))
        data = self.dump_reg(1, 0x0020, "Max Temperature", [], end='')
        print(" (%.1fC)" % (self.chipmon_code_to_temp(data)))
        data = self.dump_reg(1, 0x0021, "Max VCCint", [], end='')
        print(" (%.3fV)" % (self.chipmon_code_to_volt(data)))
        data = self.dump_reg(1, 0x0022, "Max VCCaux", [], end='')
        print(" (%.3fV)" % (self.chipmon_code_to_volt(data)))
        data = self.dump_reg(1, 0x0023, "Max VCCbram", [], end='')
        print(" (%.3fV)" % (self.chipmon_code_to_volt(data)))
        data = self.dump_reg(1, 0x0024, "Min Temperature", [], end='')
        print(" (%.1fC)" % (self.chipmon_code_to_temp(data)))
        data = self.dump_reg(1, 0x0025, "Min VCCint", [], end='')
        print(" (%.3fV)" % (self.chipmon_code_to_volt(data)))
        data = self.dump_reg(1, 0x0026, "Min VCCaux", [], end='')
        print(" (%.3fV)" % (self.chipmon_code_to_volt(data)))
        data = self.dump_reg(1, 0x0027, "Min VCCbram", [], end='')
        print(" (%.3fV)" % (self.chipmon_code_to_volt(data)))

class BlockLED(Block):
    def __init__(self, channel, blockid):
        Block.__init__(self, channel, blockid, "LED")

    def connect(self):
        Block.connect(self)
        data = self.csr_read32(0, 0)
        self.csrid = ((data >> 16) & 0xffff)
        self.numled = ((data) & 0xff)
        util.debug(f"Connect: {self} CsrId={self.csrid} NumLed={self.numled}")

    def led_status(self, led):
        data = self.csr_read32(0, 8 + (led*4))
        blinks = ((data>>16) & 0x07)
        bright_pct = (100 * ((data >> 8) & 0x3f) / 63)
        if ((data & 0x3) == 1):   return (f"on ({bright_pct}% bright)")
        elif ((data & 0x3) == 2): return (f"blink ({blinks} times, {bright_pct}% bright)")
        elif ((data & 0x3) == 3): return (f"heartbeat ({bright_pct}% bright)")
        return "off"

    def command_show(self, parts=[], help_line=False):
        if help_line: return "Shows high level status of the block in human readable form";
        for i in range(self.numled):
            util.info(f"LED {i+1:3}/{self.numled:3}: {self.led_status(i):20}")

    def command_dump(self, parts=[], help_line=False):
        if help_line: return "Dumps detailed config/status info of the block in human readable form";
        self.info(f"Dumping {self}:")
        data = self.dump_reg(0, 0x0000, "OcID", [ [31,16,"ID"], [7,0,"LED_COUNT"] ])
        count = data & 0xff
        self.dump_reg(0, 0x0004, "Prescale", [ [9,0,"CYCLES"] ])
        for i in range(count):
            self.dump_reg(0, 0x0008+i, "LedControl%d" % i, [ [18,16,"BLINKS"], [13,8,"BRIGHT"], [1,0,"MODE"] ])

    def command_set(self, parts=[], help_line=False):
        if help_line: return "Set the state of the led: [on|off|blink|heartbeat] [brightness=0-63]";
        led = -1
        bright = 0x3f
        blinks = 1
        command = -1 # report status
        prescale = -1
        while (len(parts)):
            cmd = parts.pop(0)
            if (eval_regex(r'^(\d+)$', cmd)):
                led = eval_number(m.group(1))
            elif (eval_regex(r'^status$', cmd)):
                command = -1
            elif (eval_regex(r'^off$', cmd)):
                command = 0
            elif (eval_regex(r'^on$', cmd)):
                command = 1
            elif (eval_regex(r'^blink$', cmd)):
                command = 2
            elif (eval_regex(r'^heartbeat$', cmd)):
                command = 3
            elif (eval_regex(r'^prescale=(.+)', cmd)):
                prescale = eval_number(m.group(1), check_uint_bits=10, check_int_min=5)
            elif (eval_regex(r'^bright=(.+)', cmd)):
                bright = eval_number(m.group(1), check_uint_bits=6)
            elif (eval_regex(r'^blinks=(.+)', cmd)):
                blinks = eval_number(m.group(1), check_uint_bits=3)
            else:
                print("LED ERROR: didn't understand option: %s" % cmd)
                error = 1
                return
        if prescale != -1:
            self.csr_write32(0, 4, prescale)
        if command == -1: # we reporting status
            if led == -1: # on all LEDs
                for i in range(self.numled): print("LED %3d : %s" % (  i, self.led_status(  i)))
            else:                            print("LED %3d : %s" % (led, self.led_status(led)))
        else:
            if led == -1: # on all LEDs
                for i in range(self.numled): self.csr_write32(0, 8 + (  i*4), ((blinks<<16) | (bright<<8) | command) )
            else:                            self.csr_write32(0, 8 + (led*4), ((blinks<<16) | (bright<<8) | command) )


class BlockIIC(Block):
    def __init__(self, channel, blockid):
        Block.__init__(self, channel, blockid, "IIC")

    def connect(self):
        Block.connect(self)
        data = self.csr_read32(0, 0)
        self.csrid = ((data >> 16) & 0xffff)
        self.offload_type = ((data >> 4) & 0xfff)
        self.offload_enable = ((data) & 0x1)
        names = { 0 : 'None', 1: 'Xilinx', }
        offload = names[self.offload_type] if self.offload_type in names else 'Unknown'
        util.debug(f"Connect: {self} CsrId={self.csrid} OffloadEnable={self.offload_enable} OffloadType={self.offload_type} ({offload})")

    def command_show(self, parts=[], help_line=False):
        if help_line: return "Shows high level status of the block in human readable form";
        util.info(f"{self}: OffloadEnable={self.offload_enable} OffloadType={self.offload_type}")
        data = self.csr_read32(0, 4)
        scl_in = "HIGH (IDLE)" if data&0x08 else "LOW (ACTIVE)"
        sda_in = "HIGH (IDLE)" if data&0x80 else "LOW (ACTIVE)"
        if data&0x01:  scl_in += " (MANUAL MODE)"
        if data&0x10:  sda_in += " (MANUAL MODE)"
        util.info(f"{self}: SCL: {scl_in} SDA: {sda_in}")

    def command_dump(self, parts=[], help_line=False):
        if help_line: return "Dumps detailed config/status info of the block in human readable form";
        self.info(f"Dumping {self}:")
        self.dump_reg(0, 0x0000, "OcID", [ [31,16,"ID"], [15, 4,"OFFLOAD_TYPE"], [ 0, 0,"OFFLOAD_ENABLE"] ])
        self.dump_reg(0, 0x0004, "Control", [ [31,31,"OFFLOAD_INTERRUPT"], [30,30,"OFFLOAD_DEBUG"],
                                              [7,7,"SDA_IN"], [5,5,"SDA_TRISTATE"], [4,4,"SDA_MANUAL"],
                                              [3,3,"SCL_IN"], [1,1,"SCL_TRISTATE"], [0,0,"SCL_MANUAL"] ])


class BlockGPIO(Block):
    def __init__(self, channel, blockid):
        Block.__init__(self, channel, blockid, "GPIO")

    def connect(self):
        Block.connect(self)
        data = self.csr_read32(0, 0)
        self.csrid = ((data >> 16) & 0xffff)
        self.numgpio = ((data) & 0xff)
        util.debug(f"Connect: {self} CsrId={self.csrid} NumGpio={self.numgpio}")

    def gpio_status(self, gpio):
        data = self.csr_read32(0, 4 + (gpio*4))
        if (data & 0x10): s = "driving " + "HIGH" if (data & 0x01) else "LOW"
        else:             s = "not driving (tristate)"
        s += (", receiving " + ("HIGH" if (data & 0x100) else "LOW"))
        return s

    def command_show(self, parts=[], help_line=False):
        if help_line: return "Shows high level status of the block in human readable form";
        for i in range(self.numgpio):
            util.info(f"GPIO {i+1:3}/{self.numgpio:3}: {self.gpio_status(i):20}")

    def command_dump(self, parts=[], help_line=False):
        if help_line: return "Dumps detailed config/status info of the block in human readable form";
        self.info(f"Dumping {self}:")
        data = self.dump_reg(0, 0x0000, "OcID", [ [31,16,"ID"], [7,0,"GPIO_COUNT"] ])

        
class BlockProtect(Block):
    def __init__(self, channel, blockid):
        Block.__init__(self, channel, blockid, "Protect")

    def connect(self):
        Block.connect(self)
        data = self.csr_read32(0, 0)
        self.csrid = ((data >> 16) & 0xffff)
        self.skeleton_key = ((data>>0) & 0x1)
        self.timed_license = ((data>>1) & 0x1)
        self.paranoia = ((data>>2) & 0x1)
        util.debug(f"Connect: {self} CsrId={self.csrid} SkeletonKey={self.skeleton_key},TimedLicense={self.timed_license},Paranoia={self.paranoia}")

    def command_show(self, parts=[], help_line=False):
        if help_line: return "Shows high level status of the block in human readable form";
        util.debug(f"{self}: Features: SkeletonKey={self.skeleton_key},TimedLicense={self.timed_license},Paranoia={self.paranoia}")
        data = self.csr_read32(0, 4)
        util.info(f"State: "+
                  ("Unlocked " if ((data>>31)&1) else "") +
                  ("Timed Unlock " if ((data>>30)&1) else "") +
                  ("Decryption Done " if ((data>>29)&1) else ""))
        fpga_serial = self.csr_read32(0, 8)
        bitstream_id= self.csr_read32(0, 12)
        util.info(f"FPGA Serial #: {fpga_serial:08x}, Bitstream ID: {bitstream_id:08x}")

    def command_dump(self, parts=[], help_line=False):
        if help_line: return "Dumps detailed config/status info of the block in human readable form";
        self.info(f"Dumping {self}:")
        data = self.dump_reg(0, 0x0000, "OcID", [ [31,16,"ID"], [2,2,"ENABLE_PARANOIA"], [1,1,"ENABLE_TIMED_LICENSE"], [0,0,"ENABLE_SKELETON_KEY"] ])
        self.dump_reg(0, 0x0004, "Control", [ [31,31,"UNLOCKED"], [30,30,"TIMED_UNLOCK"], [29,29,"DECRYPT_DONE"], [0,0,"DECRYPT_GO"] ])
        self.dump_reg(0, 0x0008, "License0")
        self.dump_reg(0, 0x000c, "License1")
        self.dump_reg(0, 0x0010, "FpgaSerial")
        self.dump_reg(0, 0x0014, "BitstreamID")
        self.dump_reg(0, 0x0018, "Plaintext0")
        self.dump_reg(0, 0x001c, "Plaintext1")

    def command_unlock(self, parts=[], help_line=False):
        if help_line: return "Unlocks the protected device, requires a license, given as two arguments (8-digit hex each)";
        if len(parts) != 2:
            util.error(f"Need two arguments for 'unlock'", do_exit=False)
            raise HandledError
        lic = [ eval_number(parts.pop(0), ishex=True),
                eval_number(parts.pop(0), ishex=True) ]
        self.csr_write32(0, 0x08, lic[0])
        self.csr_write32(0, 0x0c, lic[1])
        self.csr_write32(0, 0x04, 0x00000001)
        data = self.csr_read32(0, 0x04)
        if ((data>>31)&1):   util.info("License valid, FPGA unlocked")
        elif ((data>>30)&1): util.info("Demo license valid, FPGA enabled for licensed period")
        elif ((data>>29)&1): util.warning("FAIL -- key was loaded but not accepted")
        elif ((data>>0)&1):  util.warning("FAIL -- set the 'go' bit but decryption never finished?")
        else:                util.warning("FAIL -- unable to set the 'go' bit?")

class BlockDummy(Block):
    def __init__(self, channel, blockid):
        Block.__init__(self, channel, blockid, "Dummy")

    def connect(self):
        Block.connect(self)
        data = self.csr_read32(0, 0)
        self.csrid = ((data >> 16) & 0xffff)
        self.datapath_count = ((data>>0) & 0xff)
        util.debug(f"Connect: {self} CsrId={self.csrid} DatapathCount={self.datapath_count}")

    def command_show(self, parts=[], help_line=False):
        if help_line: return "Shows high level status of the block in human readable form";
        util.debug(f"{self}: Features: DatapathCount={self.datapath_count}")
        data = self.csr_read32(0, 0x04)
        util.info(f"State: "+
                  ("Done " if ((data>>31)&1) else "") +
                  ("Go " if ((data>>0)&1) else ""))
        data = self.csr_read32(0, 0x08)
        datapath_width = ((data >> 16) & 0xffff)
        datapath_pipe_stages = ((data >> 16) & 0xffff)
        data = self.csr_read32(0, 0x0c)
        datapath_logic_levels = ((data >> 24) & 0xff)
        datapath_lut_inputs = ((data >> 20) & 0xf)
        util.info(f"Logic Datapath Width: {datapath_width}-bit, {datapath_pipe_stages} pipe stages, each "+
                  f"stage is {datapath_logic_levels} logic levels of {datapath_lut_inputs}-input LUTS")

    def command_dump(self, parts=[], help_line=False):
        if help_line: return "Dumps detailed config/status info of the block in human readable form";
        self.info(f"Dumping {self}:")
        data = self.dump_reg(0, 0x0000, "OcID", [ [31,16,"ID"], [7,0,"DATAPATH_COUNT"] ])
        self.dump_reg(0, 0x0004, "Control", [ [31,31,"DONE"], [0,0,"GO"] ])
        self.dump_reg(0, 0x0008, "Param0", [ [31,16,"DATAPATH_WIDTH"], [15,0,"DATAPATH_PIPE_STAGES"] ])
        self.dump_reg(0, 0x000c, "Param1", [ [31,24,"DATAPATH_LOGIC_LEVELS"], [23,20,"DATAPATH_LUT_INPUTS"] ])
        self.dump_reg(0, 0x0010, "CurrentChunk")
        self.dump_reg(0, 0x0014, "LastChunk")
        for i in range(self.datapath_count):
            self.dump_reg(0, 0x0018+(i*4), "Result{i}")

    def command_run(self, parts=[], help_line=False):
        if help_line: return "Runs and returns signatures.  Takes one argument, the last chunk (i.e.0 means run one chunk)";
        if len(parts) != 1:
            util.error(f"Need one argument for 'run'", do_exit=False)
            raise HandledError
        num_chunks = eval_number(parts.pop(0))
        self.csr_write32(0, 0x14, num_chunks)
        self.csr_write32(0, 0x04, 1)
        data = 0
        while not (data & 0x80000000):
            data = self.csr_read32(0, 0x04)
        for i in range(self.datapath_count):
            data = self.csr_read32(0, 0x0018+(i*4))
            util.info(f"Result from DP[{i}]: {data:08x}")

    def command_check(self, parts=[], help_line=False):
        if help_line: return "Runs and returns signatures.  Requires the length and the expected results"
        if len(parts) != (1+self.datapath_count):
            util.error(f"Need {1+self.datapath_count} arguments for 'check': <length-1> and <result> (x DatapathCount) ", do_exit=False)
            raise HandledError
        num_chunks = eval_number(parts.pop(0))
        expect = []
        for i in range(self.datapath_count):
            expect.append(eval_number(parts.pop(0)))
        self.csr_write32(0, 0x14, num_chunks)
        self.csr_write32(0, 0x04, 1)
        data = 0
        while not (data & 0x80000000):
            data = self.csr_read32(0, 0x04)
        for i in range(self.datapath_count):
            data = self.csr_read32(0, 0x0018+(i*4))
            if data == expect[i]: util.info(f"Result from DP[{i}]: {data:08x} (OK)")
            else : util.warning(f"Result from DP[{i}]: {data:08x} (MISMATCH, expected {expect[i]:08x})")

# **** Register all the block classes into a table that can be queried by GUI

block_table[0] = { 'name' : 'Unknown'    , 'csrid' :  0, 'handler' : Block           }
block_table[2] = { 'name' : 'ChipMon'    , 'csrid' :  2, 'handler' : BlockChipMon    }
block_table[3] = { 'name' : 'Protect'    , 'csrid' :  3, 'handler' : BlockProtect    }
block_table[4] = { 'name' : 'Dummy'      , 'csrid' :  4, 'handler' : BlockDummy      }
block_table[5] = { 'name' : 'IIC'        , 'csrid' :  5, 'handler' : BlockIIC        }
block_table[6] = { 'name' : 'LED'        , 'csrid' :  6, 'handler' : BlockLED        }
block_table[7] = { 'name' : 'GPIO'       , 'csrid' :  7, 'handler' : BlockGPIO       }

# **************************************************************
# *** Channels
# Connect to a particular chip.  They contain standard methods
# (csr_read, info, timers, scan, etc).

class Channel:
    global block_table
    def __init__(self, name):
        self.name = name
        self.chip_info_bytes = []
        self.chip_info_strings = None
        self.chip_timers = None
        # need to read this from the RTL file
        self.block_handler = {} # <block> : <Block class>, so we can have stateful objects managing each block
        self.csrid_table = {} # <csrid> : block name as a pretty string, so we can print "Block[0] is an LED"
        self.block_dict = {} # lowercase name : block table entry, for when user types "led dump"
        for i,b in block_table.items():
            self.csrid_table[i] = b['name'] # create a table for convenient printing of name
            self.block_dict[b['name'].lower()] = b # and a dict to lookup block info by lowercase (CLI) name

    def close(self):
        util.debug(f"Closed {name}")
        self.name = name+" (closed)"
        self.chip_info_bytes = []
        self.chip_info_strings = None
        self.chip_timers = None

    def show_chip_info(self):
        self.chip_info_load()
        util.info(f"Version          : {self.chip_info_strings['version']:8}")
        util.info(f"Builder ID       : {self.chip_info_strings['builder_id']:8}")
        util.info(f"Bitstream ID     : {self.chip_info_strings['bitstream_id']:8}")
        util.info(f"Build Date       : {self.chip_info_strings['build_date']:8}")
        util.info(f"Build Time       : {self.chip_info_strings['build_time']:8}")
        util.info(f"Vendor Name      : {self.chip_info_strings['vendor_name']:8}")
        util.info(f"Library Name     : {self.chip_info_strings['library_name']:8}")
        util.info(f"Board Bame       : {self.chip_info_strings['board_name']:8}")
        util.info(f"Block Top Count  : {self.chip_info_strings['block_top_count']:8}")
        util.info(f"Block User Count : {self.chip_info_strings['block_user_count']:8}")
        util.info(f"Block Protocol   : {self.chip_info_strings['block_protocol']:8}")
        util.info(f"Userspace        : {self.chip_info_strings['userspace']}")
        util.info(f"UUID             : {self.chip_info_strings['uuid']}")

    def show_chip_timers(self):
        self.chip_timer_load()
        util.info(f"Time since reload/power : {self.chip_timers['seconds_since_reload']:10} seconds")
        util.info(f"Time since reset        : {self.chip_timers['seconds_since_reset']:10} seconds")
        util.info(f"Cycles since reset      : {self.chip_timers['cycles_since_reset']:10} cycles")
        util.info(f"Cycles under reset      : {self.chip_timers['cycles_under_reset']:10} cycles")

    def create_block_handler(self, block, handler):
        if block in self.block_handler:
            util.warning(f"Creating a block handler for block {block} but one exists, removing it")
            self.block_handler[block].disconnect()
        self.block_handler[block] = handler(self, block)
        self.block_handler[block].connect()

    def scan_chip(self, create_handlers=True, force_new_handlers=False):
        self.chip_info_load()
        for b in range(0, int(self.chip_info_strings['block_top_count'])):
            temp32 = self.csr_read32(b, 0, 0)
            csrid = ((temp32 >> 16) & 0xffff)
            params = (temp32 & 0xffff)
            name = lookup_table_string(self.csrid_table, csrid)
            util.info(f"Block {name:12} [{b:04x}] CsrId={csrid:04x} Params={params:04x}")
            if create_handlers and (force_new_handlers or not b in self.block_handler):
                if name.lower() in self.block_dict: handler = self.block_dict[name.lower()]['handler']
                else: handler = self.block_dict['unknown']['handler']
                self.create_block_handler(b, handler)

# SerialChannel is a subclass of channel that knows how to talk to the chip over serial methods (TCP Socket, or PySerial)
class SerialChannel(Channel):
    def __init__(self, port, baud):
        Channel.__init__(self, port)
        # def serial_open(port, baud):
        self.port = port
        self.baud = baud
        if port.startswith("tcp:"):
            util.debug(f"Opening FakeSerial {port}...")
            self.ser = FakeSerial(port, timeout=0.5)
            util.info(f"Opened FakeSerial {port}")
        else:
            util.debug(f"Opening {port} @ {baud}bps...")
            self.ser = serial.Serial(port=port, baudrate=baud, timeout=0.5)
            util.info(f"Opened {port} @ {baud}bps")

    def close(self):
        self.ser.close()
        Channel.close()

    def flush(self):
        util.debug(f"Channel: Flushing serial...")
        s = "."
        flushed = ""
        while len(s):
            s = self.ser.read(100)
            flushed += s.decode(encoding='UTF-8')
        util.debug(f"Channel: Flush done, got {flushed} ({len(flushed)} bytes)", level=2)

    def reset(self):
        util.debug(f"Channel: Reset, sending 64 '~' chars")
        for i in range(64):
            self.serial_write(b'~')
        time.sleep(0.01)
        s = self.serial_read(32) # read anything else that comes in after reset, like prompt, syntax error because partial byte
        util.info(f"Channel: Reset complete")

    def serial_write(self, tx_bytes, expect_echo=False, expect_prompt=False, pace_with_echo=False, pace_with_cpu=False):
        e = " (echo)" if expect_echo else ""
        p = " (prompt)" if expect_prompt else ""
        util.debug(f"Channel: writing {tx_bytes} ({len(tx_bytes)} bytes){e}{p}")
        self.ser.write(tx_bytes)
        if expect_echo:
            rx_bytes = self.ser.read(len(tx_bytes))
            if rx_bytes != tx_bytes:
                util.warning(f"Channel: sent {tx_bytes} ({len(tx_bytes)}), expected echo, got: {rx_bytes} ({len(rx_bytes)} bytes)")
        if expect_prompt:
            self.serial_read_prompt()

    def serial_read(self, length=1):
        util.debug(f"Channel: Reading {length} bytes...")
        rx_bytes = self.ser.read(length)
        util.debug(f"Channel: Read {rx_bytes} ({len(rx_bytes)} bytes)")
        return rx_bytes

    def serial_read_prompt(self):
        util.debug(f"Channel: Expecting prompt...")
        s = self.serial_read(5)
        if s != b'\r\nOC>':
            util.error(f"Channel: Ping didn't receive expected prompt, got: {s} ({len(s)} bytes)", do_exit=False)
            raise HandledError

    def serial_read_error(self):
        util.debug(f"Channel: Expecting error...")
        s = self.serial_read(12)
        if s != b'\r\nERROR\r\nOC>':
            util.error(f"Channel: Ping didn't receive expected error, got: {s} ({len(s)} bytes)", do_exit=False)
            raise HandledError

    def ping(self):
        util.debug(f"Channel: Ping, first flushing anything in channel")
        self.flush()
        util.debug(f"Channel: Pinging serial, sending \\n for prompt")
        self.serial_write(b'\n')
        self.serial_read_prompt()
        util.debug(f"Channel: Pinging serial, sending ^ for error")
        self.serial_write(b'^\n')
        self.serial_read_error()
        util.info(f"Channel: Ping OK")

    def serial_read_int32(self):
        util.debug(f"Channel: Readinf int32...")
        b = self.serial_read(4)
        i32 = ((b[0] << 24) | (b[1] << 16) | (b[2] << 8) | (b[3]))
        util.debug(f"Channel: Read int32: {i32}")
        return i32

    def chip_info_load(self):
        if self.chip_info_strings: return
        util.info(f"Loading chip info")
        self.serial_write(b'I\n')
        b = self.serial_read(64)
        self.chip_info_bytes = b
        self.chip_info_strings = {
            'version'          : ("%02x" % (b[0])),
            'builder_id'       : ("%06x" % ((b[1] << 16) | (b[2] << 8) | (b[3]))),
            'bitstream_id'     : ("%08x" % ((b[4] << 24) | (b[5] << 16) | (b[6] << 8) | (b[7]))),
            'build_date'       : ("%04x/%02x/%02x" % ((b[8] << 8) | (b[9]), (b[10]), (b[11]) )),
            'build_time'       : ("%02x:%02x" % ((b[12]), (b[13]))),
            'vendor_name'      : lookup_table_string('OC_VENDOR', ((b[14] << 8) | (b[15]))),
            'library_name'     : lookup_table_string('OC_LIBRARY', ((b[16] << 8) | (b[17]))),
            'board_name'       : lookup_table_string('OC_BOARD', ((b[18] << 8) | (b[19]))),
            'block_top_count'  : ("%04x" % ((b[20] << 8) | (b[21]))),
            'block_user_count' : ("%04x" % ((b[22] << 8) | (b[23]))),
            'block_protocol'   : ("%02x" % (b[24])),
            'userspace'        : "",
            'uuid'             : "",
        }
        for i in range (0, 16): self.chip_info_strings['userspace'] += chr(b[32+i])
        for i in range (0, 16): self.chip_info_strings['uuid']      += ("%02x" % (b[48+i]))
        self.serial_write(b'', expect_prompt=True)

    def chip_timer_load(self):
        util.info(f"Loading chip timers")
        self.serial_write(b'T\n')
        self.chip_timers = {
            'seconds_since_reload' : self.serial_read_int32(),
            'seconds_since_reset'  : self.serial_read_int32(),
            'cycles_since_reset'   : self.serial_read_int32(),
            'cycles_under_reset'   : self.serial_read_int32(),
        }
        self.serial_write(b'', expect_prompt=True)

    def bc_send(self, message, end=b'\n'):
        if len(message)<2 or len(message)>100:
            util.error(f"Cannot send BC messages >100B in length, this was: {message} ({len(message)} bytes)", do_exit=False)
            raise HandledError
        self.serial_write(b'B'+ (len(message)+1).to_bytes(1) + message + end)

    def bc_receive(self):
        b = self.serial_read(1)
        if len(b) == 0:
            util.error("Timeout waiting for response, you probably need to 'reset'")
            raise HandledError
        length = int(b[0])
        message = self.serial_read(length-1)
        return message

    def bc_send_receive(self, message, end=b'\n'):
        self.bc_send(message,end=b'') # send message, no \n to leave response channel open
        response = self.bc_receive()  # collect message response, channel will have some timeout
        self.serial_write(end)        # close the BC channel
        return response

    def csr_read32(self, block, space, address, msgid=0, verbose=False):
        util.debug(f"Channel: csr_read32(block={block},space={space},address={address:08x})")
        request = (block.to_bytes(2, 'big') +
                   b'\x01' + # read command
                   ((space<<4)+msgid).to_bytes(1) +
                   address.to_bytes(4, 'big') +
                   int(0).to_bytes(4, 'big'))
        response = self.bc_send_receive(request)
        self.serial_read_prompt()
        if len(response) != 5:
            util.error(f"Expected 5-byte response to CSR BC mesasge, got {response} ({len(response)} bytes)", do_exit=False)
            raise HandledError
        if response[0] != 1:
            util.error(f"Expected ready=1 status byte (0x01), got {response[0]:02x})", do_exit=False)
            raise HandledError
        data = int.from_bytes(response[1:5], 'big')
        if verbose or (util.args['debug']>3):
            print(f"  {data:08x} <- [{block:04x}][{space:01x}][{address:08x}]")
        return data

    def csr_write32(self, block, space, address, data, msgid=0, verbose=False):
        util.debug(f"Channel: csr_write32(block={block},space={space},address={address:08x}, data={data:08x})")
        request = (block.to_bytes(2, 'big') +
                   b'\x02' + # write command
                   ((space<<4)+msgid).to_bytes(1) +
                   address.to_bytes(4, 'big') +
                   data.to_bytes(4, 'big'))
        response = self.bc_send_receive(request)
        self.serial_read_prompt()
        if len(response) != 5:
            util.error(f"Expected 5-byte response to CSR BC mesasge, got {response} ({len(response)} bytes)", do_exit=False)
            raise HandledError
        if response[0] != 1:
            util.error(f"Expected ready=1 status byte (0x01), got {response[0]:02x})", do_exit=False)
            raise HandledError
        if verbose or (util.args['debug']>3):
            print(f"  {data:08x} -> [{block:04x}][{space:01x}][{address:08x}]")

# **************************************************************
# **** Top Level Commands

def command_set(ch, parts, help_line=False):
    global global_vars
    if help_line:
        util.info(f"Syntax: set [<var> [<value>]]")
        util.info(f"With no arguments, displays value of all variables")
        util.info(f"With one argument, displays value of one variable")
        util.info(f"With two arguments, sets value of one variable")
        util.info(f"Variables are used in various places in the OC_CLI UI, generally")
        util.info(f"using '$var' syntax in CLI inputs will use substitution if the")
        util.info(f"name matches")
        return
    if (len(parts) < 1):
        for key,value in sorted(global_vars.items()):
            util.info(f"{key}={value}")
        return
    key = parts.pop(0)
    if (len(parts)): # set
        global_vars[key] = parts.pop(0)
    else: # get
        if key in global_vars: util.info(f"SET: ${key} = {global_vars[key]}")
        else: util.warning(f"SET: var '${key}' does not exist")

def command_read (ch, parts, help_line=False):
    if help_line:
        util.info(f"Syntax: read|rd|r <address> [<block> <space> [<length> [<jump>]]]")
        return
    if (len(parts) < 1):
        util.info(f"Syntax: read|rd|r <address> [<block> <space> [<length> [<jump>]]]")
        util.error(f"Need at least an address to read", do_exit=False)
        raise HandledError
    address = eval_number(parts.pop(0), ishex=True)
    if parse_block_space(parts):
        if parse_block_space(parts) == 2:
            util.info(f"Syntax: read|rd|r <address> [<block> <space> [<length> [<jump>]]]")
            util.error(f"Need a block and space after address", do_exit=False)
            raise HandledError
    if ((address < 0) or (address > 0xffffffff)):
        util.error(f"Address {address:08x} is not a 32-bit value", do_exit=False)
        raise HandledError
    elif len(parts):
        length = eval_number(parts.pop(0), ishex=True)
        jump = 4
        if (len(parts)):
            jump = eval_number(parts.pop(0), ishex=True)
        on_this_line = 0
        for offset in range(0, length, jump):
            if (on_this_line == 0):
                print("%08x : " % (address+offset), end='')
            data = ch.csr_read32(current_block, current_space, address + offset)
            print("%08x " % data, end='')
            on_this_line += 1
            if on_this_line == 8:
                print("")
                on_this_line = 0
        if (on_this_line):
            print("")
    else:
        ch.csr_read32(current_block, current_space, address, verbose=True)

def command_write (ch, parts, help_line=False):
    if help_line:
        util.info(f"Syntax: write|wr|w <address> <data> [<block> <space> [<length> [<jump>]]]")
        return
    if (len(parts) < 2):
        util.info(f"Syntax: write|wr|w <address> <data> [<block> <space> [<length> [<jump>]]]")
        util.error(f"Need at least an address and data to write", do_exit=False)
        raise HandledError
    address = eval_number(parts.pop(0), ishex=True)
    data = eval_number(parts.pop(0), ishex=True)
    if parse_block_space(parts):
        if parse_block_space(parts) == 2:
            util.info(f"Syntax: write|wr|w <address> <data> [<block> <space> [<length> [<jump>]]]")
            util.error(f"Need a channel and space after address", do_exit=False)
            raise HandledError
    if ((address < 0) or (address > 0xffffffff)):
        util.error(f"Address {address:08x} is not a 32-bit value", do_exit=False)
        raise HandledError
    elif ((data < 0) or (data > 0xffffffff)):
        util.error(f"Data {data:08x} is not a 32-bit value", do_exit=False)
        raise HandledError
    else:
        ch.csr_write32(current_block, current_space, address, data, verbose=True)

def command_keygen(ch, parts, help_line=False):
    def usage(s="", quiet=False):
        util.info(f"Syntax: keygen create <fpga_serial:32> <bitstream_id:32> <key0:32> <key1:32> <key2:32> <key3:32> ")
        util.info(f"            ... returns <lic0:32>, <lic1:32>")
        util.info(f"        keygen check <fpga_serial:32> <bitstream_id:32> <key0:32> <key1:32> <key2:32> <key3:32> <lic0:32> <lic1:32>")
        util.info(f"            ... returns PASS/FAIL")
        util.info(f"Note: create a key for fpga_serial==0x12345678 to create a skeleton key (bitstream needs to support this)")
        util.info(f"Note: create a key for inverted bitstream_id to create a timed demo key (bitstream needs to support this)")
        if quiet: return
        util.error(s, do_exit=False)
        raise HandledError
    if len(parts) and parts[0]=='help':
        usage(quiet=True)
        return
    cmd = parts.pop(0)
    if ((cmd != 'create') and (cmd != 'check')):  usage(f"Command must be 'create' or 'check'")
    if ((cmd == 'create') and (len(parts) != 6)): usage(f"Need six arguments for 'create'")
    if ((cmd == 'check') and (len(parts) != 8)):  usage(f"Need eight arguments for 'check'")
    fpga_serial = eval_number(parts.pop(0), ishex=True)
    bitstream_id = eval_number(parts.pop(0), ishex=True)
    key = [ eval_number(parts.pop(0), ishex=True),
            eval_number(parts.pop(0), ishex=True),
            eval_number(parts.pop(0), ishex=True),
            eval_number(parts.pop(0), ishex=True) ]
    if cmd=='check':
      # we are going to decrypt the license (ciphertext) using secret bitstream key.  that should result in
      # plaintext that looks like {serial:32, bitstream:32}
      lic = [ eval_number(parts.pop(0), ishex=True), eval_number(parts.pop(0), ishex=True)]
      pt = btea(lic, -len(lic), key)
      if ((pt[0] == fpga_serial) and (pt[1] == bitstream_id)):
        util.info("PASS: License valid")
      elif ((pt[0] == 0x12345678) and (pt[1] == bitstream_id)):
        util.info("PASS: License is a valid skeleton key (if bitfile supports them)")
      elif ((pt[0] == fpga_serial) and (pt[1] == (bitstream_id^0xffffffff))):
        util.info("PASS: License is a valid timed eval key (if bitfile supports them)")
      else:
        util.warning(f"FAIL: License doesn't match")
        util.warning(f"Assuming good KEY, license is for FPGA_SERIAL={fpga_serial:08x}, BITSTREAM_ID={bitstream_id:08x}")
        util.warning(f"That bitstream ID can be checked against the secret bitstream KEY (if known) to confirm above")
    else: # create
      din = [ fpga_serial, bitstream_id ]
      lic = btea(din, len(din), key)
      util.info(f"LICENSE: {lic[0]:08x} {lic[1]:08x}")

def command_help(ch, parts):
    util.info(f"")
    util.info(f"OC_CLI HELP")
    util.info(f"")
    util.info(f"For any of these commands, get more info with '<cmd> help'...")
    util.info(f"")
    util.info(f"Terminal Basics:")
    util.info(f"  quit, debug, set, history     : as typical")
    util.info(f"")
    util.info(f"Low level channel control:")
    util.info(f"  reset, ping, info, scan       : generally start with reset, ping, info, scan")
    util.info(f"")
    util.info(f"Raw CSR access:")
    util.info(f"  read <address> [<block> [<space>]]  : aka r/rd, will cache block/space for brevity")
    util.info(f"  read, write                   : raw CSR access")
    util.info(f"")
    util.info(f"Helpful:")
    util.info(f"  keygen                        : create/check PROTECT keys")

# **************************************************************
# **** Token processing

current_block = 0
current_space = 0

def parse_block_space(parts):
    global current_block
    global current_space
    if (len(parts)): # we have been given channel + space
        if (len(parts)<2):
            return 2 # return 2 when we can't proceeed, caller prints an appropriate error
        block = eval_number(parts.pop(0))
        space = eval_number(parts.pop(0))
        if ((block < 0) or (block > 0xfff0)):
            util.error(f"Block: {block:04x} is not a valid 16-bit block", do_exit=False)
            raise HandledError
        elif ((space < 0) or (space > 0xf)):
            util.error(f"Space: {space:01x} is not a valid 4-bit space", do_exit=False)
            raise HandledError
        else:
            current_block = block
            current_space = space
    return 0


def process_tokens(ch, parts):
    global interactive_channel
    global interactive_space
    global mode_binary
    global source_stack
    command = parts.pop(0)
    try:
        if command == 'quit' or command == 'q':
            readline.write_history_file(histfile)
            sys.exit(0)
        elif command == 'history' or command == 'h' or command == 'hi' or command == 'hist':
            if (len(parts) < 1):  num_to_show = 10
            else:                 num_to_show = eval_number(parts.pop(0))
            total_items = readline.get_current_history_length()
            num_to_show = min(total_items, num_to_show)
            for i in range(num_to_show):
                print(f"{total_items-num_to_show+i+1:4} {readline.get_history_item(total_items-num_to_show+i+1)}")
        elif eval_regex(r'\!\s*(\d*)',command) :
            total_items = readline.get_current_history_length()
            if m.group(1):        num = int(m.group(1))
            elif len(parts) < 1:  num = total_items
            else:                 num = eval_number(parts.pop(0))
            if num < 1:
                util.error(f"Cannot access history line <1", do_exit=False)
                raise HandledError
            if num > total_items:
                util.error(f"Cannot access history line >{total_items}", do_exit=False)
                raise HandledError
            line = readline.get_history_item(num)
            print(f"OC_TTY->{line}")
            readline.replace_history_item(total_items-1, line)
            source_stack.append([line])
        elif command == 'debug':
            if (len(parts) < 1):
                util.info(f"Debug level is currently {util.debug_level}, change with 'debug <level>'")
                return
            util.set_debug_level( eval_number(parts.pop(0)) )
        elif command == 'ping' or command == 'p':
            ch.ping()
        elif command == 'flush':
            ch.flush()
        elif command == 'reset':
            ch.reset()
        elif command == 'info':
            ch.show_chip_info()
        elif command == 'scan':
            ch.scan_chip()
        elif command == 'timers':
            ch.show_chip_timers()
        elif command == 'read' or command == 'rd' or command == 'r':
            command_read(ch, parts)
        elif command == 'write' or command == 'wr' or command == 'w':
            command_write(ch, parts)
        # for commands within block drivers
        elif (command in ch.block_dict):
            if len(parts) < 2:
                util.info(f"Syntax: {command} <block> <command:'dump','help'> [<command-specific args>]")
                util.error(f"Need at least a block ID and a command", do_exit=False)
                raise HandledError
            block = eval_number(parts.pop(0))
            if block not in ch.block_handler:
                util.info(f"Syntax: {command} <block> <command:'dump','help'> [<command-specific args>]")
                util.error(f"Please do 'scan' first before trying to use block handlers", do_exit=False)
                raise HandledError
            handler = ch.block_handler[block]
            handler.process_tokens(parts)
        # for top level commands pulled in via plugin
        elif ("command_%s" % command) in globals():
            globals()[f"command_{command}"](ch, parts)
        else:
            util.warning(f"Didn't understand command: '{command}'")
    except HandledError:
        return
    except Exception as e:
      exc_type, exc_obj, exc_tb = sys.exc_info()
      print(traceback.format_exc())
      util.error(f"Unexpected exception ({exc_tb.tb_frame.f_code.co_filename}:{exc_tb.tb_lineno}): {str(e)}")
      return


# **************************************************************
# **** Interactive

source_stack = []

def interactive_get_line(ser):
    global source_stack
    if (len(source_stack) > 0):
        # we are sourcing commands from a file, if there's more than one we finish the latest (last) one
        source_lines = source_stack[len(source_stack)-1]
        line = source_lines.pop(0)
        full_line = ""
        m = re.match(r'^(.*)\\$', line)
        while (m):
            full_line += m.group(1)
            line = source_lines.pop(0)
            m = re.match(r'^(.*)\\$', line)
        full_line += line
        if (len(source_lines) == 0):
            source_stack.pop(-1) # we are done with all lines from the latest list, pop the list off the stack
        return full_line
    else:
        # we have no lines from source commands
        line = input('OC_TTY->')
        full_line = ""
        m = re.match(r'^(.*)\\$', line)
        while (m):
            full_line += m.group(1)
            line = input('        ')
            m = re.match(r'^(.*)\\$', line)
        full_line += line
        return full_line

def interactive(ch):
    global debug
    global m
    ch.flush()
    while 1:
        line = interactive_get_line(ch)
        m = re.match(r'^(.*)\#.*$', line)
        if m: line = m.group(1)
        parts = shlex.split(line)
        if len(parts) == 0: continue
        process_tokens(ch, parts)


# **************************************************************
# **** Interrupt Handler

def signal_handler(sig, frame):
    util.fancy_stop()
    util.info('Received Ctrl+C...', start='\nINFO: [OC_CLI] ')
    util.exit(1)

class HandledError(Exception):
    pass

# **************************************************************
# **** Read name arrays from shared file

name_tables = {
    'OC_VENDOR' : {},
    'OC_LIBRARY' : {},
    'OC_BOARD' : {},
}

def parse_names():
    global name_tables
    this_file = os.path.realpath(__file__)
    current_table = None
    filename = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', 'docs', 'names.txt')
    line = 0
    with open(filename, 'r') as f:
        line += 1
        for line in f:
            # discard comments
            m = re.match(r'^([^\#]*).*$', line)
            if m:
                line = m.group(1)
            m = re.match(r'^\s*\-\-\s+(\w+)\s+\-\-\s*$', line)
            if m:
                current_table = m.group(1)
                if current_table not in name_tables:
                    util.error(f"Unknown table {current_table} found at {filename}:{line}")
            m = re.match(r'^\s*([0-9a-fA-F]+)\s*\:\s*\"(.*)\"\s*$', line)
            if m:
                if current_table == None:
                    util.error(f"Entry outside of table declaration found at {filename}:{line}")
                name_tables[current_table][int(m.group(1),16)] = m.group(2)

def lookup_table_string(table, index):
    if isinstance(table, str) and table in name_tables:
        if index not in name_tables[table]: return "INVALID"
        return name_tables[table][index]
    if isinstance(table, list):
        if index >= len(table): return "INVALID"
        return table[index]
    if isinstance(table, dict):
        if index not in table: return "INVALID"
        return table[index]
    return "INVALID_TABLE"

# **************************************************************
# **** Startup Code

debug_respawn = False
util.progname = "OC_CLI"

def main():
    util.info("*** OpenCOS CLI ***")
    try:
        opts,args = getopt.getopt(sys.argv[1:], "hs:b:",
                                  ["help", "serial=", "baud=",
                                   "color", "no-color",
                                   "quiet", "no-quiet",
                                   "verbose", "no-verbose",
                                   "debug", "no-debug",
                                   "fancy", "no-fancy",
                                   "logfile=", "force-logfile=",
                                   ])
    except getopt.GetoptError as err:
        print(str(err))
        usage()
        sys.exit(-2)

    baud = 460800
    port = "COM1" if os.name == 'nt' else "/dev/ttyUSB2"
    for opt,arg in opts:
        if opt in ['-h', '--help']:
            usage()
            sys.exit(0)
        if opt in ['-s', '--serial']:
            port = arg
        if opt in ['-b', '--baud']:
            baud = arg
        if util.process_token(opt):
            if arg: util.proces_token(arg)

    try:
        ch = SerialChannel(port, baud)
    except Exception as e:
        if util.args['debug']: print(traceback.format_exc())
        else: print(str(e))
        usage()
        sys.exit(-3)

    parse_names()
    interactive(ch)
    ch.close()

def usage():
    print("")
    print("Usage: oc_cli [-h|--help] [-s|--serial <port>] [-b|--baud <rate>]")
    print("--help                This screen")
    print("--serial <port>       Select serial port. Defaults to COM1 on Windows, else /dev/ttyUSB2 (Xilinx default)")
    print("--baud                Select baud rate. Defaults to 460800")
    print("")
    sys.exit(0)

if __name__ == "__main__":
    # First we check if we are respawning
    this_path = os.path.realpath(__file__)
    if debug_respawn: util.debug(f"RESPAWN: this_path : '{this_path}'")
    oc_root = util.get_oc_root()
    if debug_respawn: util.debug(f"RESPAWN: oc_root   : '{oc_root}'")
    cwd = util.getcwd()
    if debug_respawn: util.debug(f"RESPAWN: cwd       : '{cwd}'")
    if oc_root and (not '-respawn' in sys.argv):
        new_path = os.path.join(oc_root, "bin", "oc_cli")
        if (this_path != new_path):
            # we are not the correct version of EDA for this Git repo, we should respawn
            util.info('%s respawning %s in %s' % (this_path, new_path, cwd))
            sys.argv[0] = new_path
            proc = subprocess.Popen(sys.argv, shell=0, cwd=cwd, universal_newlines=True)
            while True:
                try:
                    proc.communicate()
                    break
                except KeyboardInterrupt:
                    continue
            util.exit()
    signal.signal(signal.SIGINT, signal_handler)
    main()
